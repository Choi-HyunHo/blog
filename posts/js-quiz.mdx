---
title: 하루에 한 개..❗️ JS Quiz로 복습하기
date: "2023-09-01"
description: JavaScript Quiz Note
tag: JS
---

> 해당 포스트는 [https://github.com/lydiahallie/javascript-questions](https://github.com/lydiahallie/javascript-questions) 저장소를 기반으로 합니다.

회사 일 이외에 조금이라도 공부를 하고 하자는 마음으로 기반을 하자는 목적 하에 <br/> 프론트엔드 개발자의 베이스 중 베이스인 자바스크립트 감을 유지하는 목적입니다.

해당 포스트는 노트처럼 한 문제 씩 이곳에 기록. 📝

### 2023.09.01

1. What's the output?

```js
function sayHi() {
    console.log(name);
    console.log(age);
    var name = "Lydia";
    let age = 21;
}

sayHi();
```

-   A: `Lydia` and `undefined`
-   B: `Lydia` and `ReferenceError`
-   C: `ReferenceError` and `21`
-   D: `undefined` and `ReferenceError`

<details>
<summary><b>Answer</b></summary>

### Answer: D

함수 안에서, 우선 `var` 키워드를 사용해 `name` 변수를 선언 합니다. 이것은 변수를 정의한 줄에 실제로 도달할 때까지, 기본값 `undefined`으로 호이스팅 되는 것(생성단계에 메모리 공간이 설정)을 의미 합니다. `name` 변수를 출력하려는 줄에서 아직 변수를 정의하지 않았기 때문에, `undefined` 값을 유지
`var`와는 다르게 `let` 키워드(그리고 `const`)를 가진 변수는 호이스팅 되지만, 초기화 되지 않습니다. 변수를 선언(초기화)하는 줄 전에는 접근 ❌ 이건 "일시적 사각지대"라고 합니다. 변수가 선언되기 전 변수에 접근하려고 하면, JavaScript는 `ReferenceError`를 표현합니다.

</details>

<br />

### 2023.09.02

2. What's the output?

```js
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1);
}
```

-   A: 0 1 2 and 0 1 2
-   B: 0 1 2 and 3 3 3
-   C: 3 3 3 and 0 1 2

<details>
<summary><b>Answer</b></summary>

### Answer: C

JavaScript의 이벤트 큐 때문에, setTimeout의 콜백 함수는 루프가 실행된 후에 호출 됩니다. 첫 번째의 루프의 변수 i는 var 키워드를 사용해 선언되어 전역 값이 됩니다. 루프 동안, 단항 연산자 ++를 사용해 매번 i의 값을 1씩 증가. setTimeout콜백 함수가 호출되기까지, 첫 번째 예시에서의 i는 3.
두 번째 루프에서, 변수 i는 let 키워드를 사용해 선언. let(그리고 const) 키워드로 선언된 변수는 블록스코프. 각각을 반복하는 동안, i는 새로운 값을 갖게 되고, 각각의 값은 루프 스코프 안에 있습니다.

</details>

<br />

### 2023.09.03

3. What's the output?

```js
const shape = {
    radius: 10,
    diameter() {
        return this.radius * 2;
    },
    perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

-   A: `20` and `62.83185307179586`
-   B: `20` and `NaN`
-   C: `20` and `63`
-   D: `NaN` and `63`

<details>
<summary><b>Answer</b></summary>

### Answer: B

처음에 생각한 답은 A 입니다(하지만 오답,,)

`diameter`의 값은 일반 함수지만, `perimeter`의 값은 화살표 함수라는 점을 유의 합시다.

**화살표 함수**에서 `this` 키워드는 일반 함수와는 다르게 **현재 주변 스코프를 참조** 합니다! 이것은 `perimeter`를 부를 때 shape 객체가 아닌 그것을 둘러싼 스코프를 참조 합니다.

그 객체에는 `radius`라는 값은 없기 때문에 `undefined`를 반환 합니다.

</details>

<br />

### 2023.09.04

4. What's the output?

```js
+true;
!"Lydia";
```

-   A: `1` and `false`
-   B: `false` and `NaN`
-   C: `false` and `false`

<details>
<summary><b>Answer</b></summary>

### Answer: A

단항 더하기는 피연산자를 숫자로 변환 합니다. `true`는 `1`이고, `false`는 `0`이.
문자열 `'Lydia'`는 참 같은 값 입니다. 느낌표(!)는 논리적 NOT 연산자로 사용됩니다. 주요 목적은 Boolean 값을 부정하는 것입니다.
따라서 true의 부정은 false 값 이므로 2번째는 false가 됩니다.

</details>

<br />

### 2023.09.05

5. What's the output?

```js
const bird = {
    size: "small",
};

const mouse = {
    name: "Mickey",
    small: true,
};
```

-   A: `mouse.bird.size` 는 유효하지 않아요
-   B: `mouse[bird.size]` 는 유효하지 않아요
-   C: `mouse[bird['size']]` 는 유효하지 않아요
-   D: 이 모든 것은 유효해요.

<details>
<summary><b>Answer</b></summary>

### Answer: A

(와.. 전혀 몰랐다)

JavaScript에서 모든 객체의 키는 문자열이에요(심볼이 아닌 한). 객체의 키를 문자열 _형_ 으로 입력하지 않더라도, 항상 내부적으로 문자열로 변환돼요.

JavaScript는 문장을 해석(또는 분)해요. 대괄호 표기를 사용하면 첫 번째 열린 대괄호 `[`를 보고 닫힌 대괄호 `]`를 찾을 때까지 진행해요. 다 찾은 후에만 문장을 평가할 거예요.

`mouse[bird.size]`: 먼저 `'small'`인 `bird.size`를 평가해요. `mouse['small']` 은 `true`를 반환해요.

그러나 이것은 점 표기법에서 발생하지 않아요. `mouse`가 `bird`라고 불리는 키를 가지고 있지 않기 때문에, `mouse.bird`는 `undefined`임을 의미해요. 그다음에, 점 표기법을 사용해 `size`를 물어봐요: `mouse.bird.size`. `mouse.bird`는 `undefined`이기 때문에, 사실 우리가 물어보는 건 `undefined.size`에요. 이건 유효하지 않아요, 그리고 `Cannot read property 'size' of undefined`와 비슷한 오류를 던질 거예요.

</details>

<br />

### 2023.09.06

6. What's the output?

```js
let c = { greeting: "Hey!" };
let d;

d = c;
c.greeting = "Hello";
console.log(d.greeting);
```

-   A: `Hello`
-   B: `Hey!`
-   C: `undefined`
-   D: `ReferenceError`
-   E: `TypeError`

<details>
<summary><b>Answer</b></summary>

### Answer: A

> 객체의 `깊은 복사`와 `얕은 복사`의 차이를 물어보는 문제 입니다.

A가 나오는 이유는 `얕은 복사` 입니다.

> JavaScript에서 모든 객체는 서로를 동일하게 설정하면 *참조*로 상호작용해요.
> 우선, 변수 `c`는 객체에 대한 값을 갖고 있어요. 그 후 `c`가 객체에 가지고 있는 것과 동일한 참조를 `d`에 할당해요.
> 하나의 객체를 변경하면, 모든 객체가 변해요.

참조값을 복사할 때는 변수가 객체의 참조를 가리키고 있기 때문에 복사된 변수 또한 객체가 저장된 메모리 공간의 참조를 가리키고 있습니다. 그래서 복사를 하고 객체를 수정하면 두 변수는 똑같은 참조를 가리키고 있기 때문에 기존 객체를 저장한 변수에 영향을 끼칩니다. 이처럼 객체의 참조값(주소값)을 복사하는 것을 얕은 복사라고 합니다.

</details>

<br />

### 2023.09.07

7. What's the output?

```js
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

-   A: `true` `false` `true`
-   B: `false` `false` `true`
-   C: `true` `false` `false`
-   D: `false` `true` `true`

<details>
<summary><b>Answer</b></summary>

### Answer: C

> new Number()는, 내장 함수 생성자 입니다. 숫자처럼 보이지만, 사실 숫자가 아닙니다.
> 많은 추가 특성이 있고 그것은 객체 입니다.
> 그리고 '==(동등)' 와 '===(일치)' 의 차이를 물어보는 문제 입니다.

`==`연산자를 사용할 때는, 같은 `값` 을 가졌는지 여부만 확인 합니다. 모두`3`의 값을 가지고 있음으로 `true`를 반환 합니다.
그러나, `===`연산자를 사용할 때는, 값과 타입 둘 다 같아야 합니다. 추가로 `new Number()`는 숫자가 아니고. **객체** 입니다. 따라서 둘 다 `false`를 반환 합니다.

</details>

<br />

### 2023.09.08

8. What's the output?

```js
class Chameleon {
    static colorChange(newColor) {
        this.newColor = newColor;
        return this.newColor;
    }

    constructor({ newColor = "green" } = {}) {
        this.newColor = newColor;
    }
}

const freddie = new Chameleon({ newColor: "purple" });
console.log(freddie.colorChange("orange"));
```

-   A: `orange`
-   B: `purple`
-   C: `green`
-   D: `TypeError`

<details>
<summary><b>Answer</b></summary>

### Answer: d

헷갈리는 클래스,,, 왜 B라고 생각했지..

`colorChange`함수는 정적 입니다. 정적 메소드는 그것이 만들어지는 생성자에서만 살아있도록 설계되어,
어떤 자식들도 상속받을 수 없습니다. `freddie`는 자식이기 때문에, 이 함수는 상속되지 않아 `freddie`인스턴스에서는 이용할 수 없으며 `TypeError`가 주어집니다.

</details>
