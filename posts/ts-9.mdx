---
title: 한 입 크기로 잘라먹는 TS - 객체 타입의 호환성
date: "2023-05-31"
description: 슈퍼타입과 서브타입을 객체에 연관 시켜보자
tag: TS
---

> 이정환 님의 [한 입 크기로 잘라먹는 타입스크립트](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%ED%81%AC%EA%B8%B0-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/) 를 수강한 내용 입니다.

## 객체 타입의 호환성

모든 객체 타입은 각각 다른 객체 타입들과 슈퍼-서브 타입 관계를 갖습니다.

-   따라서 **업 캐스팅은 허용**하고 **다운 캐스팅은 허용하지 않습니다.**

> 업 캐스팅과 다운 캐스팅에 관한 내용이 궁금하면 [클릭](https://choi-hyunho.com/ts/8/)

### 예시

![1](https://github.com/Choi-HyunHo/hyunho-gatsby-blog/assets/87301268/17e7f813-f60a-44a5-bd3d-00fb59645202)

-   Animal 타입의 변수 animal에 Dog 타입의 변수 dog를 할당하는 것은 가능합니다.
-   그러나 반대로 dog 변수에 animal 변수의 값을 할당하는 것은 불가능합니다.

**Animal 타입이 Dog 타입의 슈퍼타입**이기 때문입니다.

### Dog 타입이 더 프로퍼티가 많은데요 ?

언뜻 보면 Dog 타입이 더 많은 프로퍼티를 정의하고 있어 슈퍼타입처럼 보일 수 있습니다.

-   `Animal` 타입은 **name과 color 프로퍼티를 갖는 모든 객체**들을 포함하는 집합으로 볼 수 있고
-   `Dog` 타입은 **name과 color 거기에다 추가로 breed 프로퍼티를 갖는 모든 객체**를 포함하는 집합으로 볼 수 있습니다.

그러므로 어떤 객체가 Dog 타입에 포함된다면 무조건 Animal 타입에도 포함됩니다. 그러나 반대로 `Animal 타입에 포함되는 모든 객체`가 **Dog 타입에 포함되는것은 아닙니다.** 따라서 결국 **Animal은 Dog의 슈퍼타입**입니다.

> 추가 프로퍼티가 없는, 조건이 더 적은 타입들이 슈퍼 타입이 됩니다.

## 초과 프로퍼티 검사

초과 프로퍼티 검사란 변수를 객체 리터럴로 초기화 할 때 발동하는 타입스크립트의 특수한 기능입니다.

-   `타입에 정의된 프로퍼티 외`의 **다른 초과된 프로퍼티를 갖는 객체**를 변수에 할당할 수 없도록 막습니다.

![2](https://github.com/Choi-HyunHo/hyunho-gatsby-blog/assets/87301268/d7dfc071-0382-4f9f-bdc0-4e8bd173964e)

Book 타입에 정의되지 않은 skill 프로퍼티를 갖는 객체를 할당하려고 했으므로 초과 프로퍼티 검사가 실패해 오류가 발생하고 있는 것 입니다.

### 초과 프로퍼티 검사가 허용되는 경우

초과 프로퍼티 검사는 단순히 `변수를 초기화` 할 때 **객체 리터럴을 사용하지만 않으면** 발생하지 않습니다.

![3](https://github.com/Choi-HyunHo/hyunho-gatsby-blog/assets/87301268/5d931f30-89b3-425d-95e4-2379cc302d4d)

-   값을 별도의 다른 변수에 보관한 다음 **변수 값을 초기화 값**으로 사용하면 발생하지 않습니다.
